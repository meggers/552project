$date
	Sat Nov  8 19:20:05 2014
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module cpu_tb $end
$var wire 16 ! pc [15:0] $end
$var wire 1 " hlt $end
$var reg 1 # clk $end
$var reg 1 $ rst_n $end
$scope module iCPU $end
$var wire 1 # clk $end
$var wire 1 $ rst_n $end
$var wire 16 % write_data [15:0] $end
$var wire 1 & stall $end
$var wire 16 ' result [15:0] $end
$var wire 2 ( read_signals [1:0] $end
$var wire 16 ) read_2 [15:0] $end
$var wire 16 * read_1 [15:0] $end
$var wire 1 + pc_write $end
$var wire 16 , pc_incr [15:0] $end
$var wire 16 - op_2 [15:0] $end
$var wire 16 . op_1 [15:0] $end
$var wire 16 / instr [15:0] $end
$var wire 1 0 if_id_write $end
$var wire 16 1 id_ex_b [15:0] $end
$var wire 2 2 forwardB [1:0] $end
$var wire 2 3 forwardA [1:0] $end
$var wire 3 4 flags [2:0] $end
$var wire 16 5 dm_read [15:0] $end
$var wire 7 6 ctrl_signals [6:0] $end
$var wire 1 7 branch $end
$var reg 6 8 CTRL_EX_MEM [5:0] $end
$var reg 7 9 CTRL_ID_EX [6:0] $end
$var reg 3 : CTRL_MEM_WB [2:0] $end
$var reg 3 ; FLAG [2:0] $end
$var reg 1 " hlt $end
$var reg 16 < pc [15:0] $end
$scope module alu_inst $end
$var wire 4 = ALUop [3:0] $end
$var wire 4 > offset [3:0] $end
$var wire 16 ? src0 [15:0] $end
$var wire 16 @ src1 [15:0] $end
$var wire 1 A shift_zr $end
$var wire 16 B shift_out [15:0] $end
$var wire 16 C padd_out [15:0] $end
$var wire 1 D nor_zr $end
$var wire 16 E nor_out [15:0] $end
$var wire 1 F and_zr $end
$var wire 16 G and_out [15:0] $end
$var wire 1 H add_zr $end
$var wire 1 I add_ov $end
$var wire 16 J add_out [15:0] $end
$var wire 1 K add_neg $end
$var reg 3 L flags [2:0] $end
$var reg 1 M neg $end
$var reg 1 N ov $end
$var reg 16 O result [15:0] $end
$var reg 1 P zr $end
$scope module add $end
$var wire 16 Q in1 [15:0] $end
$var wire 16 R in2 [15:0] $end
$var reg 1 K neg $end
$var reg 16 S out [15:0] $end
$var reg 1 I ov $end
$var reg 16 T sum [15:0] $end
$var reg 1 H zr $end
$upscope $end
$scope module andALU $end
$var wire 16 U in1 [15:0] $end
$var wire 16 V in2 [15:0] $end
$var reg 16 W out [15:0] $end
$var reg 1 F zr $end
$upscope $end
$scope module norALUE $end
$var wire 16 X in1 [15:0] $end
$var wire 16 Y in2 [15:0] $end
$var reg 16 Z ands [15:0] $end
$var reg 16 [ out [15:0] $end
$var reg 1 D zr $end
$upscope $end
$scope module padd $end
$var wire 16 \ in1 [15:0] $end
$var wire 16 ] in2 [15:0] $end
$var reg 16 ^ out [15:0] $end
$var reg 8 _ sum1 [7:0] $end
$var reg 8 ` sum2 [7:0] $end
$upscope $end
$scope module shift $end
$var wire 2 a dir [1:0] $end
$var wire 4 b shamt [3:0] $end
$var wire 16 c src [15:0] $end
$var reg 16 d inter0 [15:0] $end
$var reg 16 e inter1 [15:0] $end
$var reg 16 f inter2 [15:0] $end
$var reg 16 g out [15:0] $end
$var reg 1 A zr $end
$upscope $end
$upscope $end
$scope module branch_logic $end
$var wire 3 h condition [2:0] $end
$var wire 3 i flags [2:0] $end
$var reg 1 7 branch $end
$upscope $end
$scope module ctrl $end
$var wire 4 j instr [3:0] $end
$var reg 7 k ctrl_signals [6:0] $end
$var reg 2 l read_signals [1:0] $end
$upscope $end
$scope module data_mem $end
$var wire 16 m addr [15:0] $end
$var wire 1 # clk $end
$var wire 1 n re $end
$var wire 1 o we $end
$var wire 16 p wrt_data [15:0] $end
$var reg 16 q rd_data [15:0] $end
$upscope $end
$scope module forward_unit $end
$var wire 4 r ex_mem_rd [3:0] $end
$var wire 1 s ex_mem_rw $end
$var wire 4 t id_ex_rs [3:0] $end
$var wire 4 u id_ex_rt [3:0] $end
$var wire 4 v mem_wb_rd [3:0] $end
$var wire 1 w mem_wb_rw $end
$var reg 2 x forwarda [1:0] $end
$var reg 2 y forwardb [1:0] $end
$upscope $end
$scope module hdu $end
$var wire 1 z id_ex_mr $end
$var wire 4 { id_ex_rt [3:0] $end
$var wire 4 | if_id_rs [3:0] $end
$var wire 4 } if_id_rt [3:0] $end
$var wire 1 0 if_id_write $end
$var wire 4 ~ opcode [3:0] $end
$var wire 1 + pc_write $end
$var wire 1 & stall $end
$var reg 1 !" detected $end
$upscope $end
$scope module instr_mem $end
$var wire 16 "" addr [15:0] $end
$var wire 1 # clk $end
$var wire 1 #" rd_en $end
$var reg 16 $" instr [15:0] $end
$upscope $end
$scope module reg_file $end
$var wire 1 # clk $end
$var wire 16 %" dst [15:0] $end
$var wire 4 &" dst_addr [3:0] $end
$var wire 1 " hlt $end
$var wire 4 '" p0_addr [3:0] $end
$var wire 4 (" p1_addr [3:0] $end
$var wire 1 )" re0 $end
$var wire 1 *" re1 $end
$var wire 1 +" we $end
$var reg 16 ," p0 [15:0] $end
$var reg 16 -" p1 [15:0] $end
$var integer 32 ." indx [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ."
b0 -"
b0 ,"
0+"
1*"
1)"
b0 ("
b0 '"
b0 &"
b0 %"
b1011000100100010 $"
1#"
b0 ""
0!"
b0 ~
b0 }
b0 |
b0 {
0z
b0 y
b0 x
0w
b0 v
b0 u
b0 t
0s
b0 r
bx q
b0 p
0o
0n
b0 m
b11 l
b10 k
b0 j
b0 i
b0 h
b0 g
b0 f
b0 e
b0 d
b0 c
b0 b
b0 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b1111111111111111 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
1P
b0 O
0N
0M
b1 L
0K
b0 J
0I
1H
b0 G
1F
b1111111111111111 E
0D
b0 C
b0 B
1A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b0 8
17
b10 6
bx 5
b1 4
b0 3
b0 2
b0 1
10
b1011000100100010 /
b0 .
b0 -
b100 ,
1+
b0 *
b0 )
b11 (
b0 '
0&
b0 %
0$
0#
x"
b0 !
$end
#5
1#
#10
0#
#15
1#
#20
0#
#25
1#
